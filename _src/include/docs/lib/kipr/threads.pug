extends ../../../../exclude/docbase

block vars
  - var selected = 'lib/kipr/threads'
  - var path = ['Lib', 'Kipr', 'Threads']

block content
  // Threads
  a(name='Threads')
  h3 Threads
  p
    | The term thread is short for the phrase 'thread of execution', and represents a sequence of instructions to be
    | managed by the system as it schedules processing time among running processes. On a single processor machine,
    | like the KIPR Robot Controller, the instructions running in separate threads appear to be operating in parallel.
    | Each thread, once started, will continue until its process finishes or until it is forcibly terminated by
    | another process using the 
    code thread_destroy
    |  function. Each active thread gets a small amount of
    |  time in turn until all of its statements have been executed or it is forcibly terminated. If a thread's process
    |  cannot complete all of its statements before its turn is over, it is paused temporarily for the next thread
    |  to gets its share of time. This continues until all the active threads have gotten their slice of time and
    |  then thread processing repeats. The KIPR Robot Controller's processor is fast enough so that from the user's
    |  viewpoint it appears that all of the active processes are running in parallel.
  p
    | Functions running in threads can communicate with one another by reading and modifying global variables. The
    | global variables can be used as semaphores so that one process can signal another when it is not in a section
    | of code that might cause a conflict. Process IDs may also be stored in global variables of type
    | thread so that one process can destroy another one's thread if that is necessary program logic (think
    | in terms of a process that is in an indefinite loop monitoring sensors, so it will never finish otherwise).
  p
    | Since the operating system limits how many threads can be created, it is inadvisable to create threads in a loop.
    | Good thread management is to destroy a thread rather than leaving it hanging around once it is no longer
    | being used. Threads not destroyed by program end may still count against the operating system limit when
    | the program is run again (unless of course the system has been rebooted). This may result in a program which
    | for no observable reason ceases to work properly. It is up to the program to keep track of a thread it creates,
    | and there are no means (short of rebooting) to destroy a thread after the fact.
  p The library functions for controlling threads are:
  table(style='background-color: #f0f0f0;')
    tr
      td
        br
        .Indent
          code
            a(name='thread_createx')
            | thread_create(&lt;
          i function_name
          code &gt;);
          dl
            dd
              | Creates a thread for running the specified function and returns a value of type
              | thread, which is the thread ID to be used for running the thread as an independent
              | process.
          code
            a(name='thread_destroyx')
            | thread_destroy(&lt;
          i thread_id
          code &gt;);
          dl
            dd
              | Deactivates the specified thread if it is active (stopping its associated function) and destroys
              | its thread ID.
          code
            a(name='thread_startx')
            | thread_start(&lt;
          i thread_id
          code &gt;);
          dl
            dd
              | Activates the specified thread by running its associated process in the thread.
          code
            a(name='thread_waitx')
            | thread_wait(&lt;
          i thread_id
          code &gt;);
          dl
            dd
              | Suspends execution of the function that calls 
              code thread_wait
              |  while the specified
              |  thread remains active. It's purpose is to synchronize threads by suspending further execution
              |  of a function until the selected active threads have finished.
  .Indent
    h4 Example program for the KIPR Robot Controller using threads
    p
      | This example illustrates how to detect a button press even it occurs while the main process is paused.
    pre
      code.language-clike
        | int flag=0; // global flag to signal when side button pressed
        | void chksens() {
        |    while (1) {
        |       if (side_button()) flag = 1;
        |       msleep(100); // check side button every 1/10th second
        |    }
        | }
        |  main() {
        |    int cnt = 0;
        |    thread tid; // thread variable for holding thread id
        |    tid = thread_create(chksens); // create a thread for chksens
        |    thread_start(tid); // start chksens running in its thread
        |    while (flag == 0) { // button press during sleep is still caught
        |       display_printf(1,2,&quot;elapsed time %d   &quot;,++cnt);
        |       msleep(1000);
        |    }
        |    thread_destroy(tid); // remove the thread
        |    display_printf(0,4,&quot;done&quot;);
        | }
  // START FOOTER

