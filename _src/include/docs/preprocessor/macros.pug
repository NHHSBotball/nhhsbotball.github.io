extends ../../../exclude/docbase

block vars
  - var selected = 'preprocessor/macros'
  - var path = ['Preprocessor', 'Macros']

block content
  // Preprocessor_Macros
  a(name='Preprocessor_Macros')
  h3 Preprocessor Macros
  p
    | The
    | #define preprocessor directive specifies a macro definition. The macro definition is limited to one
    | line of code (of indefinite length). Once defined the macro will be expanded wherever it occurs in subsequent
    | program code.
  p
    | Macros are often used to provide replacement text, where the macro provides a more meaningful name; e.g.,
  .Indent
    code
      | #define RIGHT_MOTOR 0 // equate RIGHT_MOTOR with 0
      br
      | #define POWER  90 // equate POWER with 90
  p If the motor command
  .Indent
    code motor(RIGHT_MOTOR, POWER);
  p
    | is used in subsequent code, the preprocessor will expand the 
    code RIGHT_MOTOR
    |  and 
    code POWER
    |  macros, replace them with 0 and 90, respectively, so the code as prepared for compilation
    |  becomes
  .Indent
    code motor(0, 90);
  p
    | Global variables could also be used to provide meaningful names for quantities, but preprocessor macros produce
    | slightly more efficient code. The primary advantage in either case is that if testing shows that the motor
    | port or power needs to be changed, it only needs to be changed at one place in the program.
  p
    | The definition of a preprocessor macro can also specify one or more arguments to be used in expanding the macro.
    | For example,
  .Indent
    code
      | #define GO_RIGHT(power) motor(RIGHT_MOTOR,power)
  p
    | defines a macro 
    code GO_RIGHT
    |  that takes an argument ( 
    code power
    | ) and uses the macro 
    code RIGHT_MOTOR
    |  in its definition.
  p
    | If 
    code GO_RIGHT(85)
    |  appears in program code, it will expand to 
    code motor(RIGHT_MOTOR(85)
    |  which
    |  will then expand to 
    code motor(0,85)
    |  as the code prepared for compilation.
  p
    | Superficially, the use of a macro that doesn't have arguments looks like a global variable reference. Likewise,
    | the use of a macro with arguments looks like a call to a function. However, macro expansion is simply one-time
    | text replacement which occurs during preprocessing Compilation resolves global references as memory locations
    | subject to dynamic change during program execution. When called, a function evaluates and interprets its
    | arguments dynamically.
  p
    | Appropriate use of macros can make it easier to follow the C program logic and can be used to facilitate program
    | testing and modification.
  // START FOOTER

