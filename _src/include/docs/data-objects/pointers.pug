extends ../../../exclude/docbase

block vars
  - var selected = 'pointers'
  - var path = ["Data Objects", "Pointers"]

block content
  // Pointers
  a(name='PointersM')
  h3 Pointers
  p
    | A pointer is the (numeric) address of the location in memory where a data element is stored. Memory addresses
    | begin at 0 and increase by 1 for each byte of memory. Limited arithmetic operations may be performed on pointers,
    | but the value of the resulting pointer depends on the data type pointed to. For example, adding 1 to the
    | pointer for a
    | char data item increases the pointer value by 1 since that advances the pointer to the next character
    | in memory. In contrast, adding 1 to an
    | int pointer increases its value by 4 since that advances the pointer to the next integer in memory.
    | Using a pointer to try to access memory not allocated to a program will probably cause a system error or
    | crash, so it is important to insure that pointers used in a program address valid objects in memory.
  p
    | A pointer data type can be defined for any allowed data type, included user-defined data types. When used as
    | a unary operator (one argument), 
    code *
    |  is the indirection (or "value at address") operator, and
    |  is used for defining and dereferencing pointer variables. For example,
  .Indent
    code int *p;
  p
    | defines 
    code p
    |  to be a variable whose value is a pointer to a memory location holding an integer.
  p
    | When used as a unary operator, 
    code &
    |  is the memory address operator. The address of a variable named 
    code x
    |  is given by 
    code &x
    |  and so if 
    code x
    |  is an integer variable,
  .Indent
    code p=&x;
  p
    | assigns the memory address of variable 
    code x
    |  to the (integer) pointer variable 
    code p
    | .
  p
    | Retrieving the value pointed to is known as 
    i dereferencing
    |  the pointer and is given by 
    code *p
    |  for pointer variable 
    code p
    | . For the example above, both variable 
    code x
    |  and 
    code *p
    |  represent the same value in memory. 
    code *(p+1)
    |  retrieves the (integer) value of the next integer
    |  in memory (which is 4 bytes further along than 
    code x
    | ). Furthermore, the contents of the address
    |  can be changed by assigning a value to the dereferenced address; e.g.,
  .Indent
    code
      | *(p+1) = *p + 1;
  p
    | It is often useful to deal with pointers to objects, but great care must be taken to insure that the pointers
    | used at any point in your code really do point to valid objects in memory. It is easy to get confused by
    | what a pointer is addressing when it is taken from a complex structure with pointers to pointers or something
    | similar.
  p
    | Pointers are often used instead of global variables to provide a function with access to data external to the
    | function. If a pointer is passed to a function as an argument, the function then has access to the memory
    | location for the pointer, which could also represent a local variable external to the function. If the function
    | uses the pointer to change the value in the memory location, it will also have changed the value of the external
    | local variable.
  p
    | For C, the scope of function parameters is local to the function, with values assigned to them only when the
    | function is called. Programming languages typically employ one or more evaluation strategies for function
    | parameters. The ones usually cited are 
    i call by value
    | , 
    i call by reference
    | , and
    i call by name
    | .
  ul
    li
      | For 
      i call by value
      | , the parameter is treated as a local variable initialized using the value supplied
      |  for the parameter when the function is called. This is the approach used for C.
    li
      | For 
      i call by reference
      | , no local version of the parameter is created, which means it represents
      |  storage for the calling agent, even if the supplied parameter is a constant (i.e., a poorly written
      |  function could change the value of a constant passed to it by reference, which was a real problem
      |  for the early programming language FORTRAN). Although C does not use
      c
        | call by reference in the strict sense, it accomplishes the same objective by use of pointer variables
        | as parameters. When a pointer variable is used as a parameter for a function in C, by dereferencing
        | the parameter (whose scope is local) the function can access and possibly modify the value of
        | an external variable having the same address.
    li
      | For 
      i call by name
      |  the actual name supplied as the parameter is substituted throughout the function,
      |  much as the C preprocessors does for
      |  #define macros. 
      i Call by name
      |  is not supported by C in any meaningful sense.
  // START FOOTER

